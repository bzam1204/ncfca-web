test_standards:
  - code-standards: @code.standards.yml
  - utilize jest
  - id: arrange_act_assert
    rule: "Follow the Arrange–Act–Assert steps."
    bad_example: |
      it("creates a club", async () => {
        const result = await createClub({ name: "Chess" });
        expect(result.id).toBeDefined();
        const found = await repo.findByName("Chess");
        expect(found).not.toBeNull(); // Mixed flow, no clear phases
      });
    good_example: |
      it("creates a club", async () => {
        // Arrange
        const input = { name: "Chess" };

        // Act
        const result = await createClub(input);

        // Assert
        expect(result.id).toBeDefined();
        await expect(repo.findByName("Chess")).resolves.toMatchObject(input);
      })

  - id: independent_tests
    rule: "Tests should be independent from one another."
    bad_example: |
      let createdId: string;

      it("A) creates a club", async () => {
        createdId = (await createClub({ name: "Music" })).id; // shared mutable state
      });

      it("B) finds the previously created club", async () => {
        const c = await repo.findById(createdId); // depends on test A
        expect(c?.name).toBe("Music");
      });
    good_example: |
      it("creates a club", async () => {
        const { id } = await createClub({ name: "Music" });
        const found = await repo.findById(id);
        expect(found?.name).toBe("Music");
      });

      it("finds a club by name", async () => {
        await createClub({ name: "Art" });
        const found = await repo.findByName("Art");
        expect(found?.name).toBe("Art");
      });

  - id: one_behavior_per_test
    rule: "Test only one behavior per test case."
    bad_example: |
      it("creates and deletes a club", async () => {
        const c = await createClub({ name: "Drama" });
        expect(c.id).toBeDefined();
        await deleteClub(c.id);
        await expect(repo.findById(c.id)).resolves.toBeNull();
      });
    good_example: |
      it("creates a club", async () => {
        const c = await createClub({ name: "Drama" });
        expect(c.id).toBeDefined();
      });

      it("deletes a club", async () => {
        const c = await createClub({ name: "Drama" });
        await deleteClub(c.id);
        await expect(repo.findById(c.id)).resolves.toBeNull();
      });

  - id: prepare_environment_beforeEach
    rule: "Prepare the environment in beforeEach."
    example: |
      beforeEach(async () => {
        await db.reset();       // clear tables
        jest.clearAllMocks();   // reset spies/mocks
      });

      it("persists a club", async () => {
        const c = await createClub({ name: "Board Games" });
        expect(await repo.findById(c.id)).toBeTruthy();
      });

  - id: close_connections_afterAll_or_afterEach
    rule: "Always close open connections in afterAll/afterEach."
    example: |
      import { server } from "@/infra/http/server";
      import { db } from "@/infra/db";

      afterEach(async () => {
        await db.releaseTransactionIfAny(); // per-test cleanup if needed
      });

      afterAll(async () => {
        await db.disconnect();  // close DB pool
        await new Promise<void>((resolve) => server.close(() => resolve()));
      });
      
  - id: surgical_cleanup
    rule: "Test cleanup must be scoped and surgical. Each test suite is responsible for cleaning up only the data it creates, typically in an `afterAll` hook. Global, non-specific cleanup (like TRUNCATE) is forbidden."
    bad_example: |
      // FORBIDDEN: This cleans the entire database, breaking the principle of
      // surgical cleanup and potentially affecting other tests or local development data.
      beforeEach(async () => {
        await db.reset(); // Wipes all tables
      });
    good_example: |
      // CORRECT: The test suite tracks the IDs of created root entities (e.g., users)
      // and uses a specific `afterAll` hook to remove only related data.
      describe('E2E ApproveClubRequest', () => {
        let admin: { userId: string; ... };
        let regularUser: { userId: string; ... };

        beforeAll(async () => {
          // Create specific users for this test suite
          admin = await createTestUser(...);
          regularUser = await createTestUser(...);
        });

        afterAll(async () => {
          // Surgically remove only the data related to the users created above.
          await prisma.club.deleteMany({ where: { principal_id: { in: [admin.userId, regularUser.userId] } } });
          await prisma.family.deleteMany({ where: { holder_id: { in: [admin.userId, regularUser.userId] } } });
          await prisma.user.deleteMany({ where: { id: { in: [admin.userId, regularUser.userId] } } });
        });

        // ... tests ...
      });

  - id: describe_naming_convention
    rule: "The `describe` block must follow the format '(SCOPE) NameUseCase', where SCOPE is UNIT, INT, or E2E."
    bad_example: |
      describe('Testing the approval of candidates', ...)
      describe('ApproveCandidate', ...)
    good_example: |
      describe('(E2E) ApproveCandidate', ...)
      describe('(UNIT) Club', ...)

  - id: it_naming_convention
    rule: "The `it` block must describe a single business rule in Portuguese, starting with 'Deve' or 'Não deve'."
    description: "The test description must not contain implementation details like HTTP methods (e.g., POST). It must focus on the business rule being tested, using the project's ubiquitous language."
    bad_example: |
      it('POST /candidates/:id/approve should approve a candidate', ...)
      it('returns 204 on success', ...)
      it('test approval logic', ...)
    good_example: |
      it('Deve aprovar uma candidatura válida', ...)
      it('Não deve aprovar uma candidatura com documentação pendente', ...)
      it('Deve poder remover um membro do clube', ...) 